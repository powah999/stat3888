---
title: "STAT38888 - Data cleaning script"
author: "John T. Ormerod"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: show
    toc: yes
    toc_float: true
---

# About the data

Data: inp13bsp.csv 

Data dictionary: combined_dictionary.csv


# Converting the raw data to technically correct data

The first set of code chunks below "attempt" to convert the raw data to technically correct data
(I have done my best to do this, but there could still be problems with my code - it should be checked). 
The end product of the script below is to creates 9  tibbles

+ dict_XXXX - containing the special meanings of variables in the raw dataset.
+ types_XXXX - containing human readable variable names, and a guess of the variable type.
+ tech_XXXX - the technically correct dataset.

where XXXX is one of biom, nutr or food. The variable types of each variable in 
tech_XXXX should be correct, and NAs should correspond to missing values. In addition
variables containing missing values contain "_MISS" versions of the variable which contain
the *reason* the value is missing. For example the variable "PHDCMWBC" has a corresponding
variable "PHDCMWBC_MISS" containing the reason values in "PHDCMWBC" are missing.

The 9 main tibbles are then saved as an Rdata file called "tech_data.Rdata" which can be
loaded into memory using the `load("tech_data.Rdata")` command.

The following R program is meant to help get you started. I place no guarantees
that this code is bug free.

```{r setup, include=FALSE}
# Default knitting options
knitr::opts_chunk$set(echo=TRUE, # Echo the code
                      tidy=TRUE, # Nicely dity up code
                      warning=FALSE, # No warnings please 
                      message=FALSE) # No messages please

options(warn=-1) 

# Suppress start up warnings when loading libraries
library <- function(...) {
  suppressPackageStartupMessages(base::library(...))
}
```

```{r libraries}
# Load in all libraries
# install.packages("tidyverse")
# install.packages("here")
# install.packages("readxl")
# install.packages("janitor")
# install.packages("stringr")
# install.packages("tidyr")
library(tidyverse)
library(here)      # directory referencing
library(readxl)    # reading Excel files
library(janitor)   # data cleaning 
library(stringr)   # string manimpuation
library(tidyr)     # new tidy functions
```

### First we read raw data into R.

```{r read_in_raw_data}
raw_data <- read.csv(here("Indigenous Dataset/inp13bsp.csv"), header=TRUE)

head(raw_data)

nrow(raw_data)
ncol(raw_data)
```

Next we are going to create a quiet version of `readxl` function so that warning and 
other messages don't appear in the knitted version of this document.

```{r define_quiet_read_function}
quiet_read <- purrr::quietly(readxl::read_excel)
```

Read the data dictionary for each of the three data sources which are located
in sheets 1 to 3 of the "nutmstatDataItems2019.xlsx" file.

```{r read_data_dictionaries}

dict <- quiet_read(here("combined_dictionary.xlsx"),sheet=1)$result

DT::datatable(dict)
```

### Cleaning the variable names

We are going to process the data dictionary and use this information to
process the raw datasets so that they are technically correct.

```{r clean_names}
dict <- dict %>% janitor::clean_names()

DT::datatable(dict)
# dict_biom <- dict_biom %>% janitor::clean_names() %>% rename(extra=x3)  
# dict_nutr <- dict_nutr %>% janitor::clean_names() %>% rename(extra1=x3,extra2=x4) 
# dict_food <- dict_food %>% janitor::clean_names() %>% rename(extra=x3) 
```

### Remove empty rows

The next step will be to remove any empty rows from each of the raw 
datasets.

```{r remove_empty_rows}
dict <- dict %>% janitor::remove_empty("rows")
# Remove any empty rows
DT::datatable(dict)
```

The data dictionaries are organized in blocks. For example 

```{r take_a_look_at_biom2}
# install.packages("DT")

DT::datatable(dict)
```
 
The first line of each block contains a human readable name, and possibly some
extra information.


### Create datasets with human readable versions of the variable names

```{r get_first_line_of_each_block}
# Remove any empty rows
dict_readable <- dict %>% 
  filter(!is.na(sas_name))  

DT::datatable(dict_readable)

dict_readable %>%
  count(sas_name) %>%
  filter(n > 1)

which(duplicated(dict_readable$sas_name) | duplicated(dict_readable$sas_name, fromLast = TRUE))
dict_readable <- dict_readable %>%
  distinct(sas_name, .keep_all = TRUE)
```

 
### Fill in blanks in the variable names

The blocks are defined by a variable name, e.g. "BMISC" and any NAs below it
correspond to this variable. So we are going to identify the blocks using the
fill function

```{r fill_NAs_in_variable_names}
# Remove any empty rows
dict <- dict %>% tidyr::fill(sas_name)
DT::datatable(dict)
```
 

### Create a function to determine which variables are continuous and which are categorical

Next we will identify which variables are continuous, and which are factors
my performing a string search for each block for the word "continuous".

```{r}
get_type <- function(dict) 
{
  #dict <- dict_nutr
  var_names <- unique(dict$sas_name)
  var_type  <- c()
  for (j in 1:length(var_names))
  {
    # Get all dictionary lines corresponding to a varible
    # (a block of lines)
    dict_block <- dict %>% 
      filter(sas_name==var_names[j])
    
    # Take all of the characters in a block, paste them 
    # together and make all characters lower case
    block_string <- dict_block %>%
      select(-sas_name) %>%
      as.matrix() %>%
      as.vector() %>%
      paste(collapse="") %>%
      tolower()
    
    # Assign variable if we can find the word "continuous"
    # in the block otherwise assume that it is "categorical"
    var_type[j] <- block_string %>% 
      str_detect("continuous") %>% 
      ifelse("continuous","categorical") 
  }
  return(var_type)
}
```

### Try to infer the data types from the data dictionary
 
```{r, eval=TRUE}  
tib1 <- tibble(variable_type=get_type(dict))
# tib2 <- tibble(variable_type=rep("continuous",nrow(nutr_readable)))
# tib3 <- tibble(variable_type=get_type(dict_food))

# Create a new tibble that takes the readable tibble,
# appends the variable type, and do some minor fixing
nrow(dict_readable)
nrow(tib1)
types <- bind_cols(dict_readable, tib1) %>%
  mutate(variable_type=ifelse(sas_name%in%c("ABSHID"), "string",variable_type))
DT::datatable(types)
```


### Split the description varible in the data dictionary into value and meaning columns

```{r}
library(dplyr)
library(stringr)

get_special_value_meanings <- function(dict) {
  dict %>%
    select(sas_name, items_categories) %>%
    mutate(s = str_squish(items_categories)) %>%
    group_by(sas_name) %>%
    mutate(row_in_var = row_number()) %>%
    filter(row_in_var > 1) %>%               # drop header row within each SAS block
    ungroup() %>%
    # First, try to parse "number + separator + value"
    mutate(
      .m = str_match(
        s,
        "^([0-9]+(?:\\s*[-–—]\\s*[0-9]+)?)\\s*(?:[\\.:\\)]\\s*|\\s+)(.*)$"
      ),
      number = .m[, 2],
      value  = .m[, 3]
    ) %>%
    # If that failed, fill number-only or value-only cases
    mutate(
      # number-only (e.g., "2011" or "0-999")
      number = coalesce(
        number,
        str_match(s, "^([0-9]+(?:\\s*[-–—]\\s*[0-9]+)?)$")[, 2]
      ),
      # value-only: any non-empty string that's not pure number/range
      value = coalesce(
        value,
        if_else(str_detect(s, "^[0-9]+(?:\\s*[-–—]\\s*[0-9]+)?$"),
                NA_character_,
                s)
      )
    ) %>%
    mutate(
      number = str_squish(number),
      value  = str_squish(value)
    ) %>%
    select(sas_name, number, value)
}

special_data <- get_special_value_meanings(dict)
```

```{r special_biom}
DT::datatable(special_data)
```

In summary so far we have the following R objects:

+ dict_XXXX contains the dictionary category meainings.
+ special_XXXX contains the meanings of special values.
+ types_XXXX contains the variable types and human readable values.
+ raw_XXXX contains the raw data.

We will assume that special values in the data dictionary are missing values if the variable type is
"continuous". If the variable type is "categorical" then the special values are missingness indicators if
the value is one of

+ "not applicable",
+ "measurement not taken - equipment faulty",
+ "measurement not taken - other reason",
+ "measurement not taken - refusal",
+ "not collected",
+ "not determined",
+ "not known",
+ "not known if currently on a diet",
+ "not measured",
+ "not reported",
+ "not stated",
+ "not used"

Otherwise we will assume that the categorical value is a non-missing category.

Remove columns in the "food" dataset with columns we don't have dictionary items for.
These seem to be some type of "id" variables, perhaps, for state, council or suburb
level identification.

 

### Convert all categorical variables and convert them to factors in R.

```{r}
categorical_to_factor <- function(types, proc) 
{
  var_names <- colnames(proc)  
  for (i in 1:length(var_names)) 
  {
    # Extract the inferred variable type from the types tibble
    var_type <- types %>% 
      filter(sas_name==var_names[i]) %>%
      select(variable_type) %>%
      as.character()
    
    # If the type is categorical turn the variable into a factor
    if (var_type=="categorical") {
      proc[[var_names[i]]] <- as.factor(proc[[var_names[i]]])
    }
  }
  return(proc)
}
proc_data <- categorical_to_factor(types, raw_data)
# proc_biom <- categorical_to_factor(types_biom,raw_biom)
# proc_nutr <- categorical_to_factor(types_nutr,raw_nutr)
# proc_food <- categorical_to_factor(types_food,raw_food)
```

### Create a function the converts raw data to technically correct data 

```{r}
miss_defs <- c("not applicable",
               "measurement not taken - equipment faulty",
               "measurement not taken - other reason",
               "measurement not taken - refusal",
               "not collected",
               "not determined",
               "not known",
               "not known if currently on a diet",
               "not measured",
               "not reported",
               "not stated",
               "not used")

raw_to_tech <- function(proc, special, types)
{
  var_names <- colnames(proc)
  for (j in 1:length(var_names)) 
  {
    var_val <- var_names[j]
    specials <- special %>%
      filter(sas_name==var_val)
    if (nrow(specials)>0) 
    {
      ind <- which(var_names==var_val)
      var_miss_str  <- paste0(var_val,"_MISS")
      var_miss_reas <- rep("observed",nrow(proc))
      var_vals      <- proc[,ind]
      var_type <- types %>% 
        filter(sas_name==var_val) %>%
        select(variable_type) %>%
        as.character()
      if (var_type=="continuous") {
        for (i in 1:length(var_vals)) {
          if (var_vals[i] %in% specials$value) {
            ind2 <- which(var_vals[i]==specials$value)
            var_vals[i]      <- NA
            var_miss_reas[i] <- specials[ind2,3] %>% as.character()
          }
        }
      }
      if (var_type=="categorical") {
        for (i in 1:length(var_vals)) {
          spec_val  <- specials$value
          spec_meam <- specials$meaning
          if (var_vals[i] %in% spec_val) 
          {
            var_mean <- spec_meam[var_vals[i] == spec_val]
            if (var_mean %in% miss_defs) {
              var_vals[i]      <- NA
              var_miss_reas[j] <- var_mean
            }
          } else {
            var_vals[i]      <- NA
            var_miss_reas[i] <- "unknown"
          }
        }
      }
      if (any(is.na(var_vals))) {
        proc[,ind] <- var_vals
        proc$dummy <- var_miss_reas
        colnames(proc)[ncol(proc)] <- var_miss_str
      }
    }
  }
  return(proc)
}
```

### Apply the function to each of the three main datasets

```{r}
DT::datatable(proc_data)

tech_data <- raw_to_tech(proc_data, special_data, types)
tech_data
# tech_biom <- raw_to_tech(proc_biom, special_biom, types_biom)
# tech_nutr <- raw_to_tech(proc_nutr, special_nutr, types_nutr)
# tech_food <- raw_to_tech(proc_food, special_food, types_food)  
```

### Save the relevant R objects for future use.

```{r}
# head(tech_biom) 
# head(dict_biom) 
head(types_biom)
save(tech_biom, dict_biom, types_biom,
     tech_nutr, dict_nutr, types_nutr,
     tech_food, dict_food, types_food,
     file = "tech_data.Rdata")
```

